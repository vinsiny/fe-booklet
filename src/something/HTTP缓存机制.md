---
tags: [11月的]
title: HTTP 缓存机制
created: '2019-10-29T05:31:50.950Z'
modified: '2019-10-29T11:34:48.181Z'
---

# HTTP 缓存机制
### 一、 两种缓存规则

  强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。

### 1.1 强制缓存
  当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。

#### 1.1.1 浏览器实现

对于强制缓存，服务器响应的 header 中会用两个字段来表明—— Expires 和 Cache-Control。

#### 1.1.2 Expires

Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用 Cache-Control 替代。

#### 1.1.3 Cache-Control
  Cache-Control有很多属性，不同的属性代表的意义也不同：
    - private：客户端可以缓存；
    - public：客户端和代理服务器都可以缓存
    - max-age=t：缓存内容将在t秒后失效
    - no-cache：需要使用协商缓存来验证缓存数据
    - no-store：所有内容都不会缓存。
    - must-revalidate：

    
### 1.2 协商缓存
  又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。

  有两种缓存方案

#### 1.2.1 Last-Modified

  服务器在响应请求时，会告诉浏览器资源的最后修改时间。

  if-Modified-Since:
    浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。
从字面上看，就是说：从某个时间节点算起，是否文件被修改了

    如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
    如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

  if-Unmodified-Since:
    从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改

    如果没有被修改:则开始`继续'传送文件: 服务器返回: 200 OK
    如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)

    这两个的区别是一个是修改了才下载一个是没修改才下载。

    Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了 Etag。

#### 1.2.2 Etag

  Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）；

  If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比：

  1. 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
  2. 相同，说明资源无新修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.









