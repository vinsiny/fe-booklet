<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TS体操 - 前端小册</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> 前端小册</a></li><li class="chapter-item expanded "><a href="../框架/index.html"><strong aria-hidden="true">2.</strong> 框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../框架/揭秘React-setState.html"><strong aria-hidden="true">2.1.</strong> 揭秘React-setState</a></li><li class="chapter-item expanded "><a href="../框架/setStateV17.html"><strong aria-hidden="true">2.2.</strong> 揭秘React-setState-fiber</a></li><li class="chapter-item expanded "><a href="../框架/双向绑定.html"><strong aria-hidden="true">2.3.</strong> 双向绑定</a></li><li class="chapter-item expanded "><a href="../框架/ssr和Nextjs.html"><strong aria-hidden="true">2.4.</strong> SSR和Nextjs</a></li></ol></li><li class="chapter-item expanded "><a href="../JS&TS/index.html"><strong aria-hidden="true">3.</strong> JS&amp;TS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../JS&TS/ESModule.html"><strong aria-hidden="true">3.1.</strong> ESModule</a></li><li class="chapter-item expanded "><a href="../JS&TS/TS面试.html"><strong aria-hidden="true">3.2.</strong> TS面试</a></li><li class="chapter-item expanded "><a href="../JS&TS/TS体操.html" class="active"><strong aria-hidden="true">3.3.</strong> TS体操</a></li><li class="chapter-item expanded "><a href="../JS&TS/Promise实现.html"><strong aria-hidden="true">3.4.</strong> Promise实现</a></li><li class="chapter-item expanded "><a href="../JS&TS/JS原型链.html"><strong aria-hidden="true">3.5.</strong> JS原型链</a></li><li class="chapter-item expanded "><a href="../JS&TS/JS内存管理和GC.html"><strong aria-hidden="true">3.6.</strong> JS内存管理和GC</a></li><li class="chapter-item expanded "><a href="../JS&TS/JS八股.html"><strong aria-hidden="true">3.7.</strong> JS八股</a></li></ol></li><li class="chapter-item expanded "><a href="../NodeJS/index.html"><strong aria-hidden="true">4.</strong> NodeJS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../NodeJS/模块机制.html"><strong aria-hidden="true">4.1.</strong> 模块机制</a></li><li class="chapter-item expanded "><a href="../NodeJS/Buffer.html"><strong aria-hidden="true">4.2.</strong> Buffer</a></li></ol></li><li class="chapter-item expanded "><a href="../打包编译/index.html"><strong aria-hidden="true">5.</strong> 打包&amp;编译工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../打包编译/babel插件.html"><strong aria-hidden="true">5.1.</strong> babel插件</a></li><li class="chapter-item expanded "><a href="../打包编译/SplitChunks.html"><strong aria-hidden="true">5.2.</strong> SplitChunks</a></li></ol></li><li class="chapter-item expanded "><a href="../网络协议/index.html"><strong aria-hidden="true">6.</strong> 网络协议</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../网络协议/HTTP缓存.html"><strong aria-hidden="true">6.1.</strong> HTTP缓存</a></li><li class="chapter-item expanded "><a href="../网络协议/HTTPS.html"><strong aria-hidden="true">6.2.</strong> HTTPS</a></li><li class="chapter-item expanded "><a href="../网络协议/HTTP∕1和HTTP∕2.html"><strong aria-hidden="true">6.3.</strong> HTTP/1和HTTP/2</a></li><li class="chapter-item expanded "><a href="../网络协议/网络协议基础.html"><strong aria-hidden="true">6.4.</strong> 网络协议基础</a></li></ol></li><li class="chapter-item expanded "><a href="../算法/index.html"><strong aria-hidden="true">7.</strong> 算法&amp;设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../算法/设计模式.html"><strong aria-hidden="true">7.1.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../算法/控制反转和依赖注入.html"><strong aria-hidden="true">7.2.</strong> 控制反转和依赖注入</a></li></ol></li><li class="chapter-item expanded "><a href="../CSS世界/index.html"><strong aria-hidden="true">8.</strong> CSS世界</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CSS世界/响应式页面开发.html"><strong aria-hidden="true">8.1.</strong> 响应式页面开发</a></li><li class="chapter-item expanded "><a href="../CSS世界/CSS基础.html"><strong aria-hidden="true">8.2.</strong> CSS基础</a></li><li class="chapter-item expanded "><a href="../CSS世界/CSS盒模型.html"><strong aria-hidden="true">8.3.</strong> CSS盒模型</a></li><li class="chapter-item expanded "><a href="../CSS世界/CSS垂直居中.html"><strong aria-hidden="true">8.4.</strong> CSS垂直居中</a></li><li class="chapter-item expanded "><a href="../CSS世界/多屏幕尺寸适配.html"><strong aria-hidden="true">8.5.</strong> 多屏幕尺寸适配</a></li></ol></li><li class="chapter-item expanded "><a href="../something/index.html"><strong aria-hidden="true">9.</strong> 杂七杂八</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../something/ES6.html"><strong aria-hidden="true">9.1.</strong> es6</a></li><li class="chapter-item expanded "><a href="../something/Flux&Redux&Mobx.html"><strong aria-hidden="true">9.2.</strong> flux、redux、mobx</a></li><li class="chapter-item expanded "><a href="../something/Mobx.html"><strong aria-hidden="true">9.3.</strong> Mobx</a></li><li class="chapter-item expanded "><a href="../something/Issue笔记链接.html"><strong aria-hidden="true">9.4.</strong> Issue笔记链接</a></li><li class="chapter-item expanded "><a href="../something/React.html"><strong aria-hidden="true">9.5.</strong> React</a></li><li class="chapter-item expanded "><a href="../something/任务.html"><strong aria-hidden="true">9.6.</strong> 任务</a></li><li class="chapter-item expanded "><a href="../something/前端安全.html"><strong aria-hidden="true">9.7.</strong> 前端安全</a></li><li class="chapter-item expanded "><a href="../something/待深入.html"><strong aria-hidden="true">9.8.</strong> 待深入</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">前端小册</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vinsiny/fe-booklet" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/vinsiny/fe-booklet/edit/main/src/JS&amp;TS/TS体操.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ts-类型体操"><a class="header" href="#ts-类型体操">TS 类型体操</a></h2>
<h3 id="1-有哪些类型"><a class="header" href="#1-有哪些类型">1. 有哪些类型</a></h3>
<p>类型体操的主要类型列举在图中。Typescript 复用了 JS 的基础类型和复合类型，并新增元组（Tuple）、接口（Interface）、枚举（Enum）等类型，这些类型在日常开发过程中类型声明应该都很常用，不做赘述。</p>
<p><img src="./TS%E4%BD%93%E6%93%8D/1.png" alt="1" /></p>
<h3 id="2-运算逻辑"><a class="header" href="#2-运算逻辑">2. 运算逻辑</a></h3>
<p>TypeScript 支持条件、推导、联合、交叉、对联合类型做映射等 9 种运算逻辑。
<img src="./TS%E4%BD%93%E6%93%8D/2.png" alt="2" /></p>
<ul>
<li>条件：T extends U ? X : Y</li>
</ul>
<p>条件判断和 js 逻辑相同，都是如果满足条件就返回 a 否则返回 b。</p>
<pre><code class="language-ts">// 条件：extends ? :
// 如果 T 是 2 的子类型，那么类型是 true，否则类型是 false。
type isTwo&lt;T&gt; = T extends 2 ? true : false;
// false
type res = isTwo&lt;1&gt;;
</code></pre>
<ul>
<li>约束：extends</li>
</ul>
<p>通过约束语法 extends 限制类型。</p>
<pre><code class="language-ts">// 通过 T extends Length 约束了 T 的类型，必须是包含 length 属性，且 length 的类型必须是 number。
interface Length {
    length: number
}

function fn1&lt;T extends Length&gt;(arg: T): number{
    return arg.length
}
</code></pre>
<ul>
<li>推导：infer</li>
</ul>
<p>推导则是类似 js 的正则匹配，都满足公式条件时，可以提取公式中的变量，直接返回或者再次加工都可以。</p>
<pre><code class="language-ts">// 推导：infer
// 提取元组类型的第一个元素：
// extends 约束类型参数只能是数组类型，因为不知道数组元素的具体类型，所以用 unknown。
// extends 判断类型参数 T 是不是 [infer F, ...infer R] 的子类型，如果是就返回 F 变量，如果不是就不返回
type First&lt;T extends unknown[]&gt; = T extends [infer F, ...infer R] ? F : never;
// 1
type res2 = First&lt;[1, 2, 3]&gt;;
</code></pre>
<ul>
<li>联合：|</li>
</ul>
<p>联合代表可以是几个类型之一。</p>
<pre><code class="language-ts">type Union = 1 | 2 | 3
</code></pre>
<ul>
<li>交叉：&amp;</li>
</ul>
<p>交叉代表对类型做合并。</p>
<pre><code class="language-ts">type ObjType = { a: number } &amp; { c: boolean }
</code></pre>
<ul>
<li>索引查询：keyof T</li>
</ul>
<p>keyof 用于获取某种类型的所有键，其返回值是联合类型。</p>
<pre><code class="language-ts">// const a: 'name' | 'age' = 'name'
const a: keyof {
    name: string,
    age: number
} = 'name'
</code></pre>
<ul>
<li>索引访问：T[K]</li>
</ul>
<p>T[K] 用于访问索引，得到索引对应的值的联合类型。</p>
<pre><code class="language-ts">interface I3 {
  name: string,
  age: number
}

type T6 = I3[keyof I3] // string | number
</code></pre>
<ul>
<li>索引遍历： in</li>
</ul>
<p>in 用于遍历联合类型。</p>
<pre><code class="language-ts">const obj = {
    name: 'tj',
    age: 11
}

type T5 = {
    [P in keyof typeof obj]: any
}

/*
{
  name: any,
  age: any
}
*/
</code></pre>
<ul>
<li>索引重映射： as
as 用于修改映射类型的 key。</li>
</ul>
<pre><code class="language-ts">// 通过索引查询 keyof，索引访问 t[k]，索引遍历 in，索引重映射 as，返回全新的 key、value 构成的新的映射类型
type MapType&lt;T&gt; = {
    [
    Key in keyof T
    as `${Key &amp; string}${Key &amp; string}${Key &amp; string}`
    ]: [T[Key], T[Key], T[Key]]
}
// {
//     aaa: [1, 1, 1];
//     bbb: [2, 2, 2];
// }
type res3 = MapType&lt;{ a: 1, b: 2 }&gt;
</code></pre>
<h3 id="3-运算套路"><a class="header" href="#3-运算套路">3. 运算套路</a></h3>
<p>根据上面介绍的 9 种运算逻辑，我总结了 4 个类型套路。</p>
<ul>
<li>模式匹配做提取；</li>
<li>重新构造做变换；</li>
<li>递归复用做循环；</li>
<li>数组长度做计数。</li>
</ul>
<h3 id="31-模式匹配做提取"><a class="header" href="#31-模式匹配做提取">3.1 模式匹配做提取</a></h3>
<p>第一个类型套路是模式匹配做提取。</p>
<p>模式匹配做提取的意思是通过类型 extends 一个模式类型，把需要提取的部分放到通过 infer 声明的局部变量里。</p>
<p>举个例子，用模式匹配提取函数参数类型。</p>
<pre><code class="language-ts">type GetParameters&lt;Func extends Function&gt; =
    Func extends (...args: infer Args) =&gt; unknown ? Args : never;

type ParametersResult = GetParameters&lt;(name: string, age: number) =&gt; string&gt;
</code></pre>
<p>首先用 extends 限制类型参数必须是 Function 类型。</p>
<p>然后用 extends 为 参数类型匹配公式，当满足公式时，提取公式中的变量 Args。</p>
<p>实现函数参数类型的提取。</p>
<h4 id="32-重新构造做变换"><a class="header" href="#32-重新构造做变换">3.2 重新构造做变换</a></h4>
<p>第二个类型套路是重新构造做变换。</p>
<p>重新构造做变换的意思是想要变化就需要重新构造新的类型，并且可以在构造新类型的过程中对原类型做一些过滤和变换。</p>
<p>比如实现一个字符串类型的重新构造。</p>
<pre><code class="language-ts">type CapitalizeStr&lt;Str extends string&gt; =
    Str extends `${infer First}${infer Rest}`
    ? `${Uppercase&lt;First&gt;}${Rest}` : Str;

type CapitalizeResult = CapitalizeStr&lt;'tang'&gt;
</code></pre>
<p>首先限制参数类型必须是字符串类型。</p>
<p>然后用 extends 为参数类型匹配公式，提取公式中的变量 First Rest，并通过 Uppercase 封装。</p>
<p>实现了首字母大写的字符串字面量类型。</p>
<p><img src="./TS%E4%BD%93%E6%93%8D/3.png" alt="3" /></p>
<h4 id="33-递归复用做循环"><a class="header" href="#33-递归复用做循环">3.3 递归复用做循环</a></h4>
<p>第三个类型套路是递归复用做循环。</p>
<p>Typescript 本身不支持循环，但是可以通过递归完成不确定数量的类型编程，达到循环的效果。</p>
<p>比如通过递归实现数组类型反转。</p>
<pre><code class="language-ts">type ReverseArr&lt;Arr extends unknown[]&gt; =
    Arr extends [infer First, ...infer Rest]
    ? [...ReverseArr&lt;Rest&gt;, First]
    : Arr;
type ReverseArrResult = ReverseArr&lt;[1, 2, 3, 4, 5]&gt;
</code></pre>
<p>首先限制参数必须是数组类型。</p>
<p>然后用 extends 匹配公式，如果满足条件，则调用自身，否则直接返回。</p>
<p>实现了一个数组反转类型。</p>
<h4 id="34-数组长度做计数"><a class="header" href="#34-数组长度做计数">3.4 数组长度做计数</a></h4>
<p>第四个类型套路是数组长度做计数。</p>
<p>类型编程本身是不支持做加减乘除运算的，但是可以通过递归构造指定长度的数组，然后取数组长度的方式来完成数值的加减乘除。</p>
<p>比如通过数组长度实现类型编程的加法运算。</p>
<pre><code class="language-ts">type BuildArray&lt;
    Length extends number,
    Ele = unknown,
    Arr extends unknown[] = []
    &gt; = Arr['length'] extends Length
    ? Arr
    : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;

type Add&lt;Num1 extends number, Num2 extends number&gt; =
    [...BuildArray&lt;Num1&gt;, ...BuildArray&lt;Num2&gt;]['length'];


type AddResult = Add&lt;32, 25&gt;
</code></pre>
<p>首先通过递归创建一个可以生成任意长度的数组类型</p>
<p>然后创建一个加法类型，通过数组的长度来实现加法运算。</p>
<p><img src="./TS%E4%BD%93%E6%93%8D/4.png" alt="4" /></p>
<h3 id="三类型体操实践"><a class="header" href="#三类型体操实践">三、类型体操实践</a></h3>
<p>分享的第三部分是类型体操实践。</p>
<p>前面分享了类型体操的概念及常用的运算逻辑。</p>
<p>下面我们就用这些运算逻辑来解析 Typescript 内置的高级类型。</p>
<ol>
<li>解析 Typescript 内置高级类型</li>
</ol>
<ul>
<li>Partial 把索引变为可选</li>
</ul>
<p>通过 in 操作符遍历索引，为所有索引添加 ？前缀实现把索引变为可选的新的映射类型。</p>
<pre><code class="language-ts">
type TPartial&lt;T&gt; = {
    [P in keyof T]?: T[P];
};

type PartialRes = TPartial&lt;{ name: 'aa', age: 18 }&gt;
</code></pre>
<ul>
<li>Required 把索引变为必选</li>
</ul>
<p>通过 in 操作符遍历索引，为所有索引删除 ？前缀实现把索引变为必选的新的映射类型。</p>
<pre><code class="language-ts">type TRequired&lt;T&gt; = {
    [P in keyof T]-?: T[P]
}

type RequiredRes = TRequired&lt;{ name?: 'aa', age?: 18 }&gt;
</code></pre>
<ul>
<li>Readonly 把索引变为只读</li>
</ul>
<p>通过 in 操作符遍历索引，为所有索引添加 readonly 前缀实现把索引变为只读的新的映射类型。</p>
<pre><code class="language-ts">type TReadonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P]
}

type ReadonlyRes = TReadonly&lt;{ name?: 'aa', age?: 18 }&gt;
</code></pre>
<ul>
<li>Pick 保留过滤索引</li>
</ul>
<p>首先限制第二个参数必须是对象的 key 值，然后通过 in 操作符遍历第二个参数，生成新的映射类型实现。</p>
<pre><code class="language-ts">type TPick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P]
}

type PickRes = TPick&lt;{ name?: 'aa', age?: 18 }, 'name'&gt;
</code></pre>
<ul>
<li>Record 创建映射类型</li>
</ul>
<p>通过 in 操作符遍历联合类型 K，创建新的映射类型。</p>
<pre><code class="language-ts">type TRecord&lt;K extends keyof any, T&gt; = {
    [P in K]: T
}

type RecordRes = TRecord&lt;'aa' | 'bb', string&gt;
</code></pre>
<ul>
<li>Exclude 删除联合类型的一部分</li>
</ul>
<p>通过 extends 操作符，判断参数 1 能否赋值给参数 2，如果可以则返回 never，以此删除联合类型的一部分。</p>
<pre><code class="language-ts">type TExclude&lt;T, U&gt; = T extends U ? never : T

type ExcludeRes = TExclude&lt;'aa' | 'bb', 'aa'&gt;
</code></pre>
<ul>
<li>Extract 保留联合类型的一部分</li>
</ul>
<p>和 Exclude 逻辑相反，判断参数 1 能否赋值给参数 2，如果不可以则返回 never，以此保留联合类型的一部分。</p>
<pre><code class="language-ts">type TExtract&lt;T, U&gt; = T extends U ? T : never

type ExtractRes = TExtract&lt;'aa' | 'bb', 'aa'&gt;
</code></pre>
<ul>
<li>Omit 删除过滤索引</li>
</ul>
<p>通过高级类型 Pick、Exclude 组合，删除过滤索引。</p>
<pre><code class="language-ts">type TOmit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;

type OmitRes = TOmit&lt;{ name: 'aa', age: 18 }, 'name'&gt;
</code></pre>
<ul>
<li>Awaited 用于获取 Promise 的 valueType</li>
</ul>
<p>通过递归来获取未知层级的 Promise 的 value 类型。</p>
<pre><code class="language-ts">type TAwaited&lt;T&gt; =
    T extends null | undefined
        ? T
        : T extends object &amp; { then(onfulfilled: infer F): any }
            ? F extends ((value: infer V, ...args: any) =&gt; any)
                ? Awaited&lt;V&gt;
                : never
            : T;
type AwaitedRes = TAwaited&lt;Promise&lt;Promise&lt;Promise&lt;string&gt;&gt;&gt;&gt;
</code></pre>
<p>还有非常多高级类型，实现思路和上面介绍的类型套路大多一致，这里不一一赘述。</p>
<ol start="2">
<li>解析 ParseQueryString 复杂类型
重点解析的是在背景章节介绍类型体操复杂度，举例说明的解析字符串参数的函数类型。</li>
</ol>
<p>如图示 demo 所示，这个函数是用于将指定字符串格式解析为对象格式。</p>
<pre><code class="language-ts">function parseQueryString1(queryStr) {
  if (!queryStr || !queryStr.length) {
    return {}
  }
  const queryObj = {}
  const items = queryStr.split('&amp;')
  items.forEach((item) =&gt; {
    const [key, value] = item.split('=')
    if (queryObj[key]) {
      if (Array.isArray(queryObj[key])) {
        queryObj[key].push(value)
      } else {
        queryObj[key] = [queryObj[key], value]
      }
    } else {
      queryObj[key] = value
    }
  })
  return queryObj
}
</code></pre>
<p>比如获取字符串 a=1&amp;b=2 中 a 的值。</p>
<p>常用的类型声明方式如下图所示：</p>
<pre><code class="language-ts">function parseQueryString1(queryStr: string): Record&lt;string, any&gt; {
  if (!queryStr || !queryStr.length) {
    return {}
  }
  const queryObj = {}
  const items = queryStr.split('&amp;')
  items.forEach((item) =&gt; {
    const [key, value] = item.split('=')
    if (queryObj[key]) {
      if (Array.isArray(queryObj[key])) {
        queryObj[key].push(value)
      } else {
        queryObj[key] = [queryObj[key], value]
      }
    } else {
      queryObj[key] = value
    }
  })
  return queryObj
}
</code></pre>
<p>参数类型为 string，返回类型为 Record&lt;string, any&gt;，这时看到，res1.a 类型为 any，那么有没有办法，准确的知道 a 的类型是字面量类型 1 呢？</p>
<p>下面就通过类型体操的方式，来重写解析字符串参数的函数类型。</p>
<pre><code class="language-ts">type ParseParam&lt;Param extends string&gt; =
    Param extends `${infer Key}=${infer Value}`
        ? {
            [K in Key]: Value
        } : Record&lt;string, any&gt;;

type MergeParams&lt;
    OneParam extends Record&lt;string, any&gt;,
    OtherParam extends Record&lt;string, any&gt;
&gt; = {
  readonly [Key in keyof OneParam | keyof OtherParam]:
    Key extends keyof OneParam
        ? OneParam[Key]
        : Key extends keyof OtherParam
            ? OtherParam[Key]
            : never
}

type ParseQueryString&lt;Str extends string&gt; =
    Str extends `${infer Param}&amp;${infer Rest}`
        ? MergeParams&lt;ParseParam&lt;Param&gt;, ParseQueryString&lt;Rest&gt;&gt;
        : ParseParam&lt;Str&gt;;
</code></pre>
<p>首先限制参数类型是 string 类型，然后为参数匹配公式 a&amp;b，如果满足公式，将 a 解析为 key value 的映射类型，将 b 递归 ParseQueryString 类型，继续解析，直到不再满足 a&amp;b 公式。</p>
<p>最后，就可以得到一个精准的函数返回类型，res.a = 1。</p>
<p><img src="./TS%E4%BD%93%E6%93%8D/5.png" alt="5" /></p>
<h3 id="参考文档"><a class="header" href="#参考文档">参考文档</a></h3>
<ul>
<li><a href="https://jelly.jd.com/article/631049513c3bd1006a1fd2b5">一起来做类型体操</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../JS&amp;TS/TS面试.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../JS&amp;TS/Promise实现.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../JS&amp;TS/TS面试.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../JS&amp;TS/Promise实现.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
